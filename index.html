<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO Reward Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.2/web3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .card {
            width: 80px;
            height: 120px;
            border-radius: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin: 5px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .card.red { background-color: #D50000; }
        .card.blue { background-color: #1976D2; }
        .card.green { background-color: #388E3C; }
        .card.yellow { background-color: #FBC02D; color: black; }
        .card.wild { 
            background: linear-gradient(45deg, #D50000, #1976D2, #388E3C, #FBC02D);
        }
        .hand-area {
            min-height: 140px;
            background: #e0e0e0;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
        }
        .table-area {
            min-height: 140px;
            background: #d0d0d0;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .game-info {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .info-box {
            flex: 1;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #2196F3;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background-color: #0b7dda;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .wild-color-selector {
            display: none;
            margin-top: 20px;
            gap: 10px;
        }
        .color-button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
        }
        .color-button.red { background-color: #D50000; }
        .color-button.blue { background-color: #1976D2; }
        .color-button.green { background-color: #388E3C; }
        .color-button.yellow { background-color: #FBC02D; }
        .status-message {
            margin-top: 20px;
            padding: 10px;
            background-color: #e8f5e9;
            border-radius: 5px;
            text-align: center;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>UNO Reward Game</h1>
        <p id="wallet-status">Connect your wallet to play</p>
    </div>

    <div class="game-container">
        <div class="info-box">
            <h2>Game Setup</h2>
            <div>
                <label for="entry-fee">Entry Fee (ETH):</label>
                <input type="number" id="entry-fee" min="0.01" step="0.01" value="0.01">
            </div>
            <div class="action-buttons">
                <button id="create-game">Create New Game</button>
                <button id="join-game-btn">Joinn Game</button>
                <input type="number" id="game-id-input" placeholder="Game ID to join" style="width: 150px;">
            </div>
        </div>

        <div class="game-info">
            <div class="info-box">
                <h3>Game Info</h3>
                <p>Game ID: <span id="game-id">-</span></p>
                <p>Prize Pool: <span id="prize-pool">-</span> ETH</p>
                <p>Status: <span id="game-status">Not started</span></p>
            </div>
            <div class="info-box">
                <h3>Turn Info</h3>
                <p>Current Player: <span id="current-player">-</span></p>
                <p>Current Color: <span id="current-color">-</span></p>
                <p>Current Value: <span id="current-value">-</span></p>
            </div>
        </div>

        <div>
            <h3>Current Card</h3>
            <div class="table-area">
                <div id="current-card" class="card">?</div>
            </div>
        </div>

        <div>
            <h3>Your Hand</h3>
            <div id="hand-area" class="hand-area"></div>

            <div class="action-buttons">
                <button id="draw-card">Draw Card</button>
                <button id="say-uno">Say UNO!</button>
                <button id="quit-game">Quit Game</button>
            </div>

            <div id="wild-color-selector" class="wild-color-selector">
                <h4>Select a color:</h4>
                <button class="color-button red" data-color="0"></button>
                <button class="color-button blue" data-color="1"></button>
                <button class="color-button green" data-color="2"></button>
                <button class="color-button yellow" data-color="3"></button>
            </div>
        </div>

        <div class="status-message" id="status-message"></div>
    </div>

    <!-- Join Game Modal -->
    <div id="join-modal" class="overlay hidden">
        <div class="modal">
            <h2>Join Game</h2>
            <p>Enter the Game ID you want to join:</p>
            <input type="number" id="join-game-id" placeholder="Game ID">
            <div class="action-buttons">
                <button id="confirm-join">Join</button>
                <button id="cancel-join">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Contract ABI - simplified version with only the functions we need
        const contractABI = [
          {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum UnoRewardGame.CardColor",
          "name": "color",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "enum UnoRewardGame.CardType",
          "name": "cardType",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "value",
          "type": "uint8"
        }
      ],
      "name": "CardPlayed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum UnoRewardGame.CardColor",
          "name": "color",
          "type": "uint8"
        }
      ],
      "name": "ColorChosen",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "newDirection",
          "type": "uint8"
        }
      ],
      "name": "DirectionChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "entryFee",
          "type": "uint256"
        }
      ],
      "name": "GameCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "penalty",
          "type": "uint256"
        }
      ],
      "name": "GameQuit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        }
      ],
      "name": "GameStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "prize",
          "type": "uint256"
        }
      ],
      "name": "GameWon",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        }
      ],
      "name": "PlayerDrawsCard",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "cardCount",
          "type": "uint8"
        }
      ],
      "name": "PlayerDrawsMultiple",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        }
      ],
      "name": "PlayerJoined",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        }
      ],
      "name": "PlayerSkipped",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "MIN_ENTRY_FEE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    },
    {
      "inputs": [],
      "name": "QUIT_PENALTY",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    },
    {
      "inputs": [],
      "name": "WIN_MULTIPLIER",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "games",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "totalPrize",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isActive",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isFinished",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "currentPlayerIndex",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "playDirection",
          "type": "uint8"
        },
        {
          "internalType": "enum UnoRewardGame.CardColor",
          "name": "currentColor",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "currentValue",
          "type": "uint8"
        },
        {
          "internalType": "enum UnoRewardGame.CardType",
          "name": "currentType",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "playerCount",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "lastActionTime",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "playerActiveGame",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    },
    {
      "stateMutability": "payable",
      "type": "receive",
      "payable": true
    },
    {
      "inputs": [],
      "name": "createGame",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function",
      "payable": true
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        }
      ],
      "name": "joinGame",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function",
      "payable": true
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        }
      ],
      "name": "startGame",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "internalType": "enum UnoRewardGame.CardColor",
          "name": "color",
          "type": "uint8"
        },
        {
          "internalType": "enum UnoRewardGame.CardType",
          "name": "cardType",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "value",
          "type": "uint8"
        },
        {
          "internalType": "enum UnoRewardGame.CardColor",
          "name": "chosenColor",
          "type": "uint8"
        }
      ],
      "name": "playCard",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        }
      ],
      "name": "drawCard",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        }
      ],
      "name": "sayUno",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "quitGame",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        }
      ],
      "name": "getGameStatus",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isActive",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isFinished",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "currentPlayerIndex",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "playDirection",
          "type": "uint8"
        },
        {
          "internalType": "enum UnoRewardGame.CardColor",
          "name": "currentColor",
          "type": "uint8"
        },
        {
          "internalType": "enum UnoRewardGame.CardType",
          "name": "currentType",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "currentValue",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "playerCount",
          "type": "uint8"
        },
        {
          "internalType": "uint256",
          "name": "totalPrize",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "currentPlayerAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "playerIndex",
          "type": "uint8"
        }
      ],
      "name": "getPlayerInfo",
      "outputs": [
        {
          "internalType": "address",
          "name": "playerAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "entryFee",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "hasJoined",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "hasQuit",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "player",
          "type": "address"
        }
      ],
      "name": "getPlayerActiveGame",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function",
      "constant": true
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        }
      ],
      "name": "cleanupInactiveGame",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
        ];

        // Contract address - this would need to be replaced with your deployed contract address
        const contractAddress = "0xA89DDbD6784D6A69608988A36580eeDd09799c96"; // Replace with actual contract address when deployed

        // Helper arrays and objects
        const colorNames = ["Red", "Blue", "Green", "Yellow", "Wild"];
        const cardTypeNames = ["Number", "Skip", "Reverse", "DrawTwo", "Wild", "WildDrawFour"];

        // Game state variables
        let web3;
        let provider;
        let contract;
        let accounts;
        let currentAccount;
        let activeGameId = 0;
        let currentGameStatus = {};
        let lastHandledPenaltyState = null;
        let selectedCard = null;
        let selectedWildColor = 0;
        let playerHand = []; // Simulated hand - in a real app would come from a game server
        let statusRefreshInterval;

        // Initialize the application
        async function init() {
            if (window.ethereum) {
                try {
                    // Request account access
                    accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    currentAccount = accounts[0];
                    
                    // Initialize web3 and contract
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    const signer = provider.getSigner();
                    contract = new ethers.Contract(contractAddress, contractABI, signer);
                    
                    updateWalletStatus();
                    addEventListeners();
                    
                    // Check if player is already in a game
                    await checkActiveGame();
                    
                    // Setup wallet change listeners
                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    
                    // Set up interval for refreshing game status
                    if (activeGameId > 0) {
                        statusRefreshInterval = setInterval(refreshGameStatus, 10000); // refresh every 10 seconds
                    }
                    
                    setStatusMessage("Wallet connected successfully!");
                } catch (error) {
                    console.error("User denied account access", error);
                    setStatusMessage("Failed to connect wallet. Please try again.");
                }
            } else {
                setStatusMessage("Ethereum wallet not detected. Please install MetaMask.");
            }
        }

        // Handle account change in MetaMask
        function handleAccountsChanged(newAccounts) {
            accounts = newAccounts;
            currentAccount = accounts[0];
            updateWalletStatus();
            checkActiveGame();
        }

        // Update wallet connection status
        function updateWalletStatus() {
            const walletStatus = document.getElementById("wallet-status");
            if (currentAccount) {
                walletStatus.textContent = `Connected: ${currentAccount.substring(0, 6)}...${currentAccount.substring(38)}`;
            } else {
                walletStatus.textContent = "Connect your wallet to play";
            }
        }

        // Check if player is already in a game
        async function checkActiveGame() {
            try {
                if (!contract || !currentAccount) return;
                
                const gameId = await contract.getPlayerActiveGame(currentAccount);
                activeGameId = gameId.toNumber();
                
                if (activeGameId > 0) {
                    document.getElementById("game-id").textContent = activeGameId;
                    await refreshGameStatus();
                    // Generate a sample hand for demonstration
                    generateSampleHand();
                    setStatusMessage("Found your active game!");
                    
                    // Start the status refresh interval
                    if (!statusRefreshInterval) {
                        statusRefreshInterval = setInterval(refreshGameStatus, 10000);
                    }
                } else {
                    // Clear the status refresh interval if not in a game
                    if (statusRefreshInterval) {
                        clearInterval(statusRefreshInterval);
                        statusRefreshInterval = null;
                    }
                }
            } catch (error) {
                console.error("Error checking active game:", error);
            }
        }

        // Add event listeners to buttons
        function addEventListeners() {
            document.getElementById("create-game").addEventListener("click", createGame);
            document.getElementById("join-game-btn").addEventListener("click", () => {
                const gameId = document.getElementById("game-id-input").value;
                if (gameId) {
                    joinGame(gameId);
                } else {
                    setStatusMessage("Please enter a Game ID to join");
                }
            });
            document.getElementById("draw-card").addEventListener("click", drawCard);
            document.getElementById("say-uno").addEventListener("click", sayUno);
            document.getElementById("quit-game").addEventListener("click", quitGame);
            
            // Wild card color selector
            document.querySelectorAll(".color-button").forEach(button => {
                button.addEventListener("click", function() {
                    selectedWildColor = parseInt(this.dataset.color);
                    playSelectedCard();
                });
            });
        }

        // Create a new game
        async function createGame() {
            try {
                if (!contract || !currentAccount) {
                    setStatusMessage("Please connect your wallet first.");
                    return;
                }
                
                const entryFee = document.getElementById("entry-fee").value;
                if (!entryFee || parseFloat(entryFee) < 0.01) {
                    setStatusMessage("Minimum entry fee is 0.01 ETH");
                    return;
                }
                
                const entryFeeWei = ethers.utils.parseEther(entryFee);
                
                setStatusMessage("Creating game... Please confirm the transaction.");
                const tx = await contract.createGame({ value: entryFeeWei });
                await tx.wait();
                
                // After transaction is mined, check active game
                await checkActiveGame();
                setStatusMessage(`Game created with ID: ${activeGameId}. Waiting for opponent...`);
            } catch (error) {
                console.error("Error creating game:", error);
                setStatusMessage(`Error creating game: ${error.message || error}`);
            }
        }

        // Join an existing game
        async function joinGame(gameIdToJoin) {
            try {
                if (!contract || !currentAccount) {
                    setStatusMessage("Please connect your wallet first.");
                    return;
                }
                
                if (!gameIdToJoin || parseInt(gameIdToJoin) <= 0) {
                    setStatusMessage("Please enter a valid Game ID");
                    return;
                }
                
                // First, get the game's status to check the entry fee
                try {
                    const gameStatus = await contract.getGameStatus(gameIdToJoin);
                    const entryFeePerPlayer = gameStatus[9].div(gameStatus[8] || 1); // totalPrize / playerCount
                    
                    setStatusMessage("Joining game... Please confirm the transaction.");
                    const tx = await contract.joinGame(gameIdToJoin, { value: entryFeePerPlayer });
                    await tx.wait();
                    
                    // After transaction is mined, check active game
                    activeGameId = parseInt(gameIdToJoin);
                    document.getElementById("game-id").textContent = activeGameId;
                    await refreshGameStatus();
                    generateSampleHand();
                    setStatusMessage(`Successfully joined game ${gameIdToJoin}!`);
                    
                    // Start the status refresh interval
                    if (!statusRefreshInterval) {
                        statusRefreshInterval = setInterval(refreshGameStatus, 10000);
                    }
                } catch (error) {
                    console.error("Error fetching game status:", error);
                    setStatusMessage("Failed to get game information. The game might not exist.");
                }
            } catch (error) {
                console.error("Error joining game:", error);
                setStatusMessage(`Error joining game: ${error.message || error}`);
            }
        }

        // Draw a card from the deck
        async function drawCard() {
            try {
                if (!activeGameId || !contract) {
                    setStatusMessage("No active game found.");
                    return;
                }
                
                // Check if it's the player's turn
                const gameStatus = await contract.getGameStatus(activeGameId);
                if (gameStatus[10].toLowerCase() !== currentAccount.toLowerCase()) {
                    setStatusMessage("It's not your turn.");
                    return;
                }
                
                setStatusMessage("Drawing card... Please confirm the transaction.");
                const tx = await contract.drawCard(activeGameId);
                await tx.wait();
                
                // Simulate drawing a card (in a real app would come from event)
                const randomCard = generateRandomCard();
                playerHand.push(randomCard);
                renderHand();
                
                await refreshGameStatus();
                setStatusMessage("Card drawn!");
            } catch (error) {
                console.error("Error drawing card:", error);
                setStatusMessage(`Error drawing card: ${error.message || error}`);
            }
        }

        // Play a card
        async function playCard(card) {
            try {
                if (!activeGameId || !contract) {
                    setStatusMessage("No active game found.");
                    return;
                }
                
                // Check if it's the player's turn
                const gameStatus = await contract.getGameStatus(activeGameId);
                if (gameStatus[10].toLowerCase() !== currentAccount.toLowerCase()) {
                    setStatusMessage("It's not your turn.");
                    return;
                }
                
                // If it's a wild card, show the color selector first
                if (card.type === 4 || card.type === 5) {
                    selectedCard = card;
                    document.getElementById("wild-color-selector").style.display = "flex";
                    return;
                }
                
                selectedCard = card;
                playSelectedCard();
            } catch (error) {
                console.error("Error playing card:", error);
                setStatusMessage(`Error playing card: ${error.message || error}`);
            }
        }

        // Play the selected card after wild color selection
        async function playSelectedCard() {
            try {
                if (!selectedCard) return;
                
                const card = selectedCard;
                document.getElementById("wild-color-selector").style.display = "none";
                
                // For demonstration, we'll check if this is the last card
                const isLastCard = playerHand.length === 1;
                const value = card.type === 0 ? card.value : 0;
                
                setStatusMessage("Playing card... Please confirm the transaction.");
                
                // Play the card
                const tx = await contract.playCard(
                    activeGameId,
                    card.color,
                    card.type,
                    isLastCard ? 99 : value, // Special value 99 indicates last card
                    card.type === 4 || card.type === 5 ? selectedWildColor : 0
                );
                await tx.wait();
                
                // Remove card from hand
                playerHand = playerHand.filter(c => 
                    !(c.color === card.color && c.type === card.type && c.value === card.value)
                );
                
                renderHand();
                await refreshGameStatus();
                
                if (isLastCard) {
                    setStatusMessage("You've played your last card! If valid, you've won!");
                } else {
                    setStatusMessage("Card played successfully!");
                }
                lastHandledPenaltyState = null;
                selectedCard = null;
            } catch (error) {
                console.error("Error playing selected card:", error);
                setStatusMessage(`Error playing card: ${error.message || error}`);
                selectedCard = null;
            }
        }

        // Say UNO when you have one card left
        async function sayUno() {
            try {
                if (!activeGameId || !contract) {
                    setStatusMessage("No active game found.");
                    return;
                }
                
                if (playerHand.length !== 1) {
                    setStatusMessage("You can only say UNO when you have exactly one card left!");
                    return;
                }
                
                setStatusMessage("Saying UNO... Please confirm the transaction.");
                const tx = await contract.sayUno(activeGameId);
                await tx.wait();
                
                setStatusMessage("UNO!");
            } catch (error) {
                console.error("Error saying UNO:", error);
                setStatusMessage(`Error saying UNO: ${error.message || error}`);
            }
        }

        // Quit the current game
        async function quitGame() {
            try {
                if (!activeGameId || !contract) {
                    setStatusMessage("No active game found.");
                    return;
                }
                
                const confirmQuit = confirm("Are you sure you want to quit? You'll lose 50% of your entry fee.");
                if (!confirmQuit) return;
                
                setStatusMessage("Quitting game... Please confirm the transaction.");
                const tx = await contract.quitGame();
                await tx.wait();
                
                // Clear game state
                activeGameId = 0;
                playerHand = [];
                renderHand();
                document.getElementById("game-id").textContent = "-";
                document.getElementById("prize-pool").textContent = "-";
                document.getElementById("game-status").textContent = "Not started";
                document.getElementById("current-player").textContent = "-";
                document.getElementById("current-color").textContent = "-";
                document.getElementById("current-value").textContent = "-";
                document.getElementById("current-card").className = "card";
                document.getElementById("current-card").textContent = "?";
                
                // Clear the status refresh interval
                if (statusRefreshInterval) {
                    clearInterval(statusRefreshInterval);
                    statusRefreshInterval = null;
                }
                
                setStatusMessage("You've quit the game.");
            } catch (error) {
                console.error("Error quitting game:", error);
                setStatusMessage(`Error quitting game: ${error.message || error}`);
            }
        }

        // Refresh the current game status
        async function refreshGameStatus() {
            try {
                if (!activeGameId || !contract) return;
                
                const gameStatus = await contract.getGameStatus(activeGameId);
                currentGameStatus = {
                    isActive: gameStatus[0],
                    isFinished: gameStatus[1],
                    winner: gameStatus[2],
                    currentPlayerIndex: gameStatus[3],
                    playDirection: gameStatus[4],
                    currentColor: gameStatus[5],
                    currentType: gameStatus[6],
                    currentValue: gameStatus[7],
                    playerCount: gameStatus[8],
                    totalPrize: ethers.utils.formatEther(gameStatus[9]),
                    currentPlayerAddress: gameStatus[10]
                };
                
                // Update UI with game status
                document.getElementById("prize-pool").textContent = currentGameStatus.totalPrize;
                document.getElementById("game-status").textContent = 
                    currentGameStatus.isFinished ? "Finished" : 
                    currentGameStatus.isActive ? "Active" : "Waiting";
                
                // If game is won, update status
                if (currentGameStatus.winner !== "0x0000000000000000000000000000000000000000") {
                    const shortWinnerAddress = formatAddress(currentGameStatus.winner);
                    document.getElementById("game-status").textContent = 
                        `Finished - Winner: ${shortWinnerAddress}`;
                        
                    // If player is the winner, show celebration
                    if (currentGameStatus.winner.toLowerCase() === currentAccount.toLowerCase()) {
                        setStatusMessage("ðŸŽ‰ Congratulations! You've won the game! ðŸŽ‰");
                    } else {
                        setStatusMessage("Game over. Better luck next time!");
                    }
                    
                    // Clear the active game ID when the game is finished
                    if (statusRefreshInterval) {
                        clearInterval(statusRefreshInterval);
                        statusRefreshInterval = null;
                    }
                }
                
                // Update current player
                const currentPlayerShort = formatAddress(currentGameStatus.currentPlayerAddress);
                document.getElementById("current-player").textContent = currentPlayerShort;
                
                // Update current color and value
                document.getElementById("current-color").textContent = colorNames[currentGameStatus.currentColor];
                
                if (currentGameStatus.currentType === 0) { // Number card
                    document.getElementById("current-value").textContent = currentGameStatus.currentValue;
                } else {
                    document.getElementById("current-value").textContent = cardTypeNames[currentGameStatus.currentType];
                }
                
                // Update current card display
                updateCurrentCardDisplay();
                
                // Check if it's player's turn and update UI accordingly
                const isPlayerTurn = currentGameStatus.currentPlayerAddress.toLowerCase() === currentAccount.toLowerCase();
                document.getElementById("draw-card").disabled = !isPlayerTurn || currentGameStatus.isFinished;
                
                // Check if player needs to draw cards due to Draw Two or Wild Draw Four penalty
               // Replace the current if/else block that checks for penalties with this:
if (isPlayerTurn && !currentGameStatus.isFinished) {
    // Create a unique identifier for the current game state
    const currentPenaltyState = `${activeGameId}-${currentGameStatus.currentPlayerIndex}-${currentGameStatus.currentType}`;
    
    if ((currentGameStatus.currentType === 3 || currentGameStatus.currentType === 5) && 
        lastHandledPenaltyState !== currentPenaltyState) {
        // Only handle penalty if we haven't handled this exact state before
        lastHandledPenaltyState = currentPenaltyState;
        
        if (currentGameStatus.currentType === 3) { // Draw Two
            setStatusMessage("Draw Two penalty! Drawing 2 cards...");
            setTimeout(() => {
                handleDrawPenalty(2);
            }, 1000);
        } else if (currentGameStatus.currentType === 5) { // Wild Draw Four
            setStatusMessage("Wild Draw Four penalty! Drawing 4 cards...");
            setTimeout(() => {
                handleDrawPenalty(4);
            }, 1000);
        }
    } else if (currentGameStatus.currentType !== 3 && currentGameStatus.currentType !== 5) {
        setStatusMessage("It's your turn!");
    }
} else if (currentGameStatus.isFinished) {
    // Status already updated above if game is finished
} else if (currentGameStatus.playerCount < 2) {
    setStatusMessage("Waiting for another player to join...");
} else {
    setStatusMessage("Waiting for opponent's move...");
}
            } catch (error) {
                console.error("Error refreshing game status:", error);
            }
        }
        // Handle drawing cards due to penalty
        async function handleDrawPenalty(cardCount) {
            try {
                if (!activeGameId || !contract) return;
        
                // First draw the cards to your hand (client-side only)
                for (let i = 0; i < cardCount; i++) {
                    const randomCard = generateRandomCard();
                    playerHand.push(randomCard);
                }
                renderHand();
        
                // Then execute the drawCard contract function to advance the turn
                const tx = await contract.drawCard(activeGameId);
                await tx.wait();
        
                await refreshGameStatus();
                setStatusMessage(`Drew ${cardCount} cards due to penalty. Your turn is skipped.`);
            } catch (error) {
                console.error(`Error handling draw ${cardCount} penalty:`, error);
                setStatusMessage(`Error drawing penalty cards: ${error.message || error}`);
            }
        } 

        // Update the current card display
        function updateCurrentCardDisplay() {
            const cardElement = document.getElementById("current-card");
            cardElement.className = "card";
            
            const color = currentGameStatus.currentColor;
            const type = currentGameStatus.currentType;
            const value = currentGameStatus.currentValue;
            
            if (color < 4) { // Not wild
                cardElement.classList.add(colorNames[color].toLowerCase());
                
                if (type === 0) { // Number card
                    cardElement.textContent = value;
                } else {
                    switch(type) {
                        case 1: cardElement.textContent = "â›”"; break; // Skip
                        case 2: cardElement.textContent = "â†º"; break;  // Reverse
                        case 3: cardElement.textContent = "+2"; break; // Draw Two
                        case 4: cardElement.textContent = "W"; break;  // Wild
                        case 5: cardElement.textContent = "+4"; break; // Wild Draw Four
                        default: cardElement.textContent = "?";
                    }
                }
            } else { // Wild card
                cardElement.classList.add("wild");
                cardElement.textContent = type === 5 ? "+4" : "W";
            }
        }

        // Format address for display
        function formatAddress(address) {
            return address.substring(0, 6) + "..." + address.substring(38);
        }

        // Display status message
        function setStatusMessage(message) {
            const statusElement = document.getElementById("status-message");
            statusElement.textContent = message;
            
            // Highlight the message briefly
            statusElement.style.backgroundColor = "#c8e6c9";
            setTimeout(() => {
                statusElement.style.backgroundColor = "#e8f5e9";
            }, 1000);
        }

        // Generate a sample hand for demonstration purposes
        function generateSampleHand() {
            playerHand = [];
            const handSize = 7;
            
            for (let i = 0; i < handSize; i++) {
                playerHand.push(generateRandomCard());
            }
            
            renderHand();
        }

        // Generate a random card for demonstration
        function generateRandomCard() {
            const color = Math.floor(Math.random() * 4); // 0-3 for red, blue, green, yellow
            let type, value;
            
            const typeRandom = Math.random();
            if (typeRandom < 0.7) {
                // 70% chance of number card
                type = 0; // Number
                value = Math.floor(Math.random() * 10); // 0-9
            } else if (typeRandom < 0.85) {
                // 15% chance of special card (skip, reverse, draw two)
                type = Math.floor(Math.random() * 3) + 1; // 1-3
                value = 0;
            } else {
                // 15% chance of wild card
                type = Math.floor(Math.random() * 2) + 4; // 4-5 (wild or wild draw four)
                value = 0;
                return { color: 4, type, value }; // Special color 4 for wild
            }
            
            return { color, type, value };
        }

        // Render the player's hand
        function renderHand() {
            const handArea = document.getElementById("hand-area");
            handArea.innerHTML = "";
            
            // Update UNO button state
            document.getElementById("say-uno").disabled = playerHand.length !== 1;
            
            playerHand.forEach(card => {
                const cardElement = document.createElement("div");
                cardElement.className = "card";
                
                // Add color class
                if (card.color < 4) {
                    cardElement.classList.add(colorNames[card.color].toLowerCase());
                    
                    if (card.type === 0) { // Number card
                        cardElement.textContent = card.value;
                    } else {
                        switch(card.type) {
                            case 1: cardElement.textContent = "â›”"; break; // Skip
                            case 2: cardElement.textContent = "â†º"; break;  // Reverse
                            case 3: cardElement.textContent = "+2"; break; // Draw Two
                            default: cardElement.textContent = "?";
                        }
                    }
                } else { // Wild card
                    cardElement.classList.add("wild");
                    cardElement.textContent = card.type === 5 ? "+4" : "W";
                }
                
                // Add click event
                cardElement.addEventListener("click", () => {
                    playCard(card);
                });
                
                handArea.appendChild(cardElement);
            });
        }

        // Check if a card can be played on the current card
        function canPlayCard(card) {
            if (!currentGameStatus) return false;
            
            // Wild cards can always be played
            if (card.type === 4 || card.type === 5) return true;
            
            // If colors match
            if (card.color === currentGameStatus.currentColor) return true;
            
            // If number cards and values match
            if (card.type === 0 && currentGameStatus.currentType === 0 && 
                card.value === currentGameStatus.currentValue) return true;
            
            // If special cards and types match
            if (card.type === currentGameStatus.currentType && card.type !== 0) return true;
            
            return false;
        }

        // Initialize when page loads
        window.addEventListener("load", init);
    </script>
</body>
</html>